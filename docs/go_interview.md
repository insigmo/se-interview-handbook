Массивы и слайсы:
https://www.youtube.com/watch?v=7ij3u-0YsJI&t=911s
_______________
Map
https://habr.com/ru/companies/simbirsoft/articles/899180/
https://depot.dev/blog/go-remote-cache?utm_medium=kristen&utm_campaign=blog&utm_source=reddit&dub_id=dS0LnMNegUvx6Ufc
_______________
Планировщик горутин:
Видео от создателя(Там он еще старой версии, но большинство объяснений почему это реализовано именно так сохранилось)
https://www.youtube.com/watch?v=-K11rY57K7k&t=367s
Свежее видео работе планировщика
https://www.youtube.com/watch?v=P2Tzdg8n9hw&t=16s
https://www.youtube.com/watch?v=kedW1xO3Zbo
_______________
Interface
**В Go интерфейсный тип выглядит вот так:**
```go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
```
- `tab *itab`: Это указатель на таблицу интерфейса (`itable`), которая содержит информацию о типе и методах, необходимых для реализации интерфейса. Эта таблица помогает Go определить, какие методы доступны для данного интерфейсного значения и как их вызывать. (описание см. ниже)
- `data unsafe.Pointer`: Это указатель на конкретные данные или значение, которые реализуют интерфейс. Использование `unsafe.Pointer` позволяет интерфейсу ссылаться на данные произвольного типа, сохраняя при этом информацию о том, как к ним обращаться через `itab`.
```go
type itab struct {       // 40 bytes on a 64bit arch
	inter *interfacetype // тип интерфейса
	_type *_type         // все, что мы знаем про тип из которого образован элемент интерфейса
	hash  uint32         // copy of _type.hash. Used for type switches.
	_     [4]byte
	fun   [1]uintptr     // методы, которые должна описывать структура, чтобы релизовывать интерфейс
}
```
- `inter *interfacetype`: Метаданные интерфейса.
- `_type *_type`: Указатель на информацию о конкретном типе, который реализует интерфейс. Это позволяет Go знать, как обращаться с данными, которые реализуют интерфейс.
- `hash uint32`: Хеш типа, который используется для оптимизации операций с интерфейсами, таких как type switches.
- `fun [1]uintptr`: Массив указателей на функции, которые должны быть реализованы для удовлетворения интерфейса. Это позволяет динамически вызывать методы на интерфейсных значениях. uintptr - целочисленное представление адреса в памяти, указатель на первый элемент массива, который содержит указатели на методы. Размер массива [1], чтобы сохранить указатель на первый элемент массива.

**Компилятор генерирует метаданные для каждого статического типа, в которых, помимо прочего, хранится список методов, реализованных для данного типа.** Аналогично генерируются метаданные со списком методов для каждого интерфейса. Теперь, во время исполнения программы, runtime Go может вычислить itable на лету (late binding) для каждой конкретной пары. Этот itable кешируется, поэтому просчёт происходит только один раз.

Зная это, становится очевидно, почему Go ловит несоответствия типов на этапе компиляции, но кастинг к интерфейсу — во время исполнения.

**Что важно помнить — переменная интерфейсного типа может принимать nil. Но так как объект интерфейса в Go содержит два поля: tab и data — по правилам Go, интерфейс может быть равен nil только если оба этих поля не определены (faq):**
```go
var (
    builder  *strings.Builder
    stringer fmt.Stringer
)

fmt.Println(builder, stringer) // nil nil
fmt.Println(stringer == nil)   // true
fmt.Println(builder == nil)    // true

stringer = builder

fmt.Println(builder, stringer) // nil nil
fmt.Println(stringer == nil)   // false (!!!)
fmt.Println(builder == nil)    // true
```
____________________________________________________________
ВЫРАВНИВАНИЕ
Каждое поле в структуре выравнивается в памяти так, чтобы его адрес был кратен размеру этого поля. Например:
- **`int64`, `uint64`, `float64`, `complex64`: 8 байт**
- **`int32`, `uint32`, `float32`, `complex32`: 4 байта**
- **`int16`, `uint16`: 2 байта**
- **`int8`, `uint8`, `bool`: 1 байт**
- **Указатели и ссылки (`*T`): 8 байт (так как это указатели)**
- **Строки (`string`): 16 байт (структура с указателем и длиной)**
- **Срезы (`[]T`): 24 байта (указатель, длина, емкость)**
- **Указатель: 8 байт**
- **Размер (len): 8 байт**
- **Ёмкость (cap): 8 бай**
____________________________________________________________
Это означает, что если поле меньшего размера (например, `bool` или `int8`) расположено перед полем большего размера (например, `int64`), между ними могут вставляться **дополнительные байты** **(паддинг**), чтобы соблюсти требования выравнивания для большего поля. Эти дополнительные байты увеличивают общий размер структуры.
INIT
В Go есть предопределенная функция init(). **Она выделяет фрагмент кода, который должен выполняться перед всеми другими частями пакета. Этот код будет выполняться сразу после импорта пакета.**
Также функция init() используется для автоматической регистрации одного пакета в другом** (например, так работает подавляющее большинство "драйверов" для различных СУБД, например — go-sql-driver/mysql/driver.go).
**Функцию init() можно использовать неоднократно в рамках даже одного файла, выполняться они будут в этом случае в порядке, как их встречает компилятор.**
Хотя использование init() и является довольно полезным, но часто оно затрудняет чтение/понимание кода, и (почти) всегда можно обойтись без неё, поэтому необходимость её использования — всегда очень большой вопрос.
___________________________________________________________
DEFER
https://habr.com/ru/companies/otus/articles/833702/
___________________________________________________________
ПАМЯТЬ
**Стек (stack) — это область оперативной памяти, которая создаётся для каждого потока. Он работает в порядке LIFO (Last In, First Out), то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека. Каждый раз, когда функция объявляет новую переменную, она добавляется в стек, а когда эта переменная пропадает из области видимости (например, когда функция заканчивается), она автоматически удаляется из стека. Когда стековая переменная освобождается, эта область памяти становится доступной для других стековых переменных.**
**Стек поддерживает две основные операции:**
- **Push: добавление элемента на вершину стека.**
- **Pop: удаление и возврат элемента с вершины стека.**
**Кроме того, часто используются:**
- **Peek (или Top): получение элемента на вершине стека без его удаления.**
- **isEmpty: проверка, пуст ли стек.**
- **Стек быстрый, так как часто привязан к кэшу процессора. Размер стека ограничен, и задаётся при создании потока.**
**Куча (heap) — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти и не работает по принципу стека: это просто склад для ваших переменных.** Когда вы выделяете в куче участок памяти для хранения переменной, **к ней можно обратиться не только в потоке, но и во всем приложении.** **Именно так определяются глобальные переменные. По завершении приложения все выделенные участки памяти освобождаются.** **Размер кучи задаётся при запуске приложения, но, в отличие от стека, он ограничен лишь физически, и это позволяет создавать динамические переменные.**
- **В сравнении со стеком, куча работает медленнее, поскольку переменные разбросаны по памяти, а не сидят на верхушке стека. То что попадает в кучу, живёт там пока не придёт GC.**
**Стеку не нужно иметь сборщик мусора (garbage collector). Как мы уже упоминали, переменные просто создаются и затем вытесняются, когда функция завершается. Не нужно запускать сложный процесс освобождения памяти от неиспользуемых переменных и т.п.**
- **Стек принадлежит одной горутине, переменные не нужно синхронизировать в сравнении с теми, что находятся в куче. Что также повышает производительность**
_________________________________________________________
Контекст
https://habr.com/ru/companies/pt/articles/764850/
_________________________________________________________
Garbage collection:
https://habr.com/ru/companies/avito/articles/753244/
https://habr.com/ru/articles/742402/
В целом, алгоритм можно представить циклом из нескольких шагов:
1. Покрасить все корневые объекты (стек и глобальные переменные) в серый.
2. Выбрать серый объект из набора серых объектов и пометить его как чёрный.
3. Все объекты, на которые указывает чёрный объект, пометить серым. Это гарантирует, что сам объект и объекты, на которые он ссылается, не будут выброшены в мусор.
4. Если в графе остались серые объекты, вернуться к шагу 2.
**Sweep termination — фаза завершения очистки:**
- **Stop the World**
- **Ожидаем пока все горутины достигнут safe-point**
- **Завершаем очистку ресурсов**
**Mark phase — фаза разметки (выполняется конкурентно с основной программой, выделяется на неё ~25% CPU):**
- **Включаем Write Barrier**
- **Start the World**
- **Запускаем сканирование глобальных переменных и стеков**
- **При сканировании работа горутины приостанавливается (но не происходит полная остановка всей программы)**
- **Выполняем 3-х цветный алгоритм поиска мусора**
**Mark termination — фаза завершения разметки**
- **Stop the World (не является обязательной, но с ней проце было реализовать)**
- **Дожидаемся завершения обработки последних задач из очереди**
- **Очистка кэшей**
- **Завершаем разметку**
**Sweep phase — фаза очистки**
- **Отключаем Write Barrier**
- **Start The World**
- **Очистка ресурсов происходит в фоне**
**Для оптимизации можно:**
- **Уменьшить частоту вызова GC с помощью GOGC**
- **Использовать балласт (выделять большое количество памяти при запуске приложения make([]byte, 10 << 30) // 10 GiB), который увеличивает базовый размер кучи, не будет выделен как мусор, помечается за O(1), и выделяется в виртуальном пространстве не используя физическую память**
- **Использовать sync.Pool (он хорошо дружит с GC)**
__________________________________________________________
Посмотреть как работают каналы
Паттерны каналов:
https://www.youtube.com/watch?v=luQlkud-jKE&t=5s
__________________________________________________________
Синхронизация:
Mutex vs RWMutex, семафор и WaitGroup
https://victoriametrics.com/blog/go-sync-once/
https://ubiklab.net/posts/go-sync-cond/
https://ubiklab.net/posts/go-pool-and-mechanics-behind-it/
__________________________________________________________
RESTAPI
https://www.youtube.com/watch?v=08-RlaLgWx4&t=232s
__________________________________________________________
Redis
https://www.youtube.com/watch?v=Ry57f5seKRQ
https://www.youtube.com/watch?v=QpBaA6B1U90&t=2s
__________________________________________________________
WebSocket
https://www.youtube.com/watch?v=19d4AXt3dSI
https://www.youtube.com/watch?v=9pjmpipo7xc
__________________________________________________________
gRPC
https://www.youtube.com/watch?v=_EqVG-El5z0&t=5s
https://www.youtube.com/watch?v=bfdF4AJELDc&t=6s
https://www.youtube.com/watch?v=DGBLwNN-YM4
__________________________________________________________
Kafka
https://www.youtube.com/watch?v=hbseyn-CfXY&t=4273s
__________________________________________________________
SQL
Типы индексов postgreSQL
### Основные типы индексов в PostgreSQL
1. **B-Tree (по умолчанию)**  
    **Это наиболее часто используемый тип индексов, подходящий для равенства (`=`), неравенства (`<>`, `>=`, `<=`) и диапазонов (`BETWEEN`). B-Tree индексы автоматически создаются при создании `PRIMARY KEY` и `UNIQUE` ограничений.**
    **`CREATE INDEX idx_employee_age ON employee(age);`**
    
2. **Hash индекс**  
    **Используется для поиска по точному совпадению (`=`). Hash индексы менее универсальны, чем B-Tree, и подходят только для равенства. Начиная с PostgreSQL 10, они поддерживают транзакционность и безопасны для использования. Однако, они обычно уступают B-Tree по производительности и занимают больше места.**
    **`CREATE INDEX idx_employee_name_hash ON employee USING HASH (name);`**
    
3. **GIN (Generalized Inverted Index)**  
    **Специальный тип индекса для работы с массивами, JSONB, и полнотекстовым поиском. GIN индексы помогают ускорить поиск элементов внутри сложных структур данных, например, в текстах или JSON-объектах.**
    **`CREATE INDEX idx_articles_content ON articles USING GIN (content);`**
    
4. **GiST (Generalized Search Tree)**  
    **Подходит для индексации данных, где важны пространственные операции (например, географические данные), а также для поиска по диапазонам и полнотекстового поиска. Широко используется вместе с расширениями, такими как PostGIS для работы с геоданными.**
    **`CREATE INDEX idx_locations_coords ON locations USING GiST (coordinates);`**
    
5. **SP-GiST (Space-Partitioned Generalized Search Tree)**  
    **Используется для индексирования данных с неравномерным распределением, таких как географические и сетевые данные. SP-GiST позволяет более эффективно обрабатывать данные с редкими значениями.**
    
6. **BRIN (Block Range INdex)**  
    **Это легкий индекс, который индексирует блоки строк, а не каждую строку, что экономит пространство. Подходит для больших таблиц с последовательными данными, например, для временных данных, и используется для анализа данных за периоды.**
    **`CREATE INDEX idx_logs_timestamp ON logs USING BRIN (timestamp);

Оптимистическая блокировка и Пессимистическая блокировка**
Виды JOIN:https://timeweb.com/ru/community/articles/kak-rabotaet-sql-join
Уровни изоляций транзакций:https://habr.com/ru/articles/845522/
Типы связей:https://habr.com/ru/articles/488054/
Что такое нормализация и денермализация:
https://habr.com/ru/companies/mvideo/articles/783386/
https://habr.com/ru/articles/254773/
EXPLAIN и EXPLAIN ANALYZE:https://aglamov.biz/jazyki-programmirovanija/bazy-dannyh/postgresql/indeksy-i-optimizacija-zaprosov-v-postgresql-uskorjaem-rabotu-bazy-dannyh
Репликация:https://habr.com/ru/articles/514500/
Парционирование:https://habr.com/ru/articles/273933/
Шардирование:https://www.youtube.com/watch?v=d6BtxBKhQoc&t=267s
________________________________________________________________
Задания которые нужно решать не сразу :
https://leetcode.com/studyplan/top-sql-50/
________________________________________________________________


