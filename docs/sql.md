# Вопросы по СУБД/SQL

#### **1\. Что такое транзакция? ACID свойства. Уровни изолированности.**

Транзакция — группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно идущих других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого эффекта.

**ACID свойства**

| Atomicity — Атомарность | Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. |
| :---- | :---- |
| Consistency — Согласованность | Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. |
| Isolation — Изолированность | Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. |
| Durability — Устойчивость | Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из\-за какого-либо сбоя. |

**При параллельном выполнении транзакций возможны следующие проблемы:**  
*потерянное обновление (англ. lost update)* — при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего;  
*«грязное» чтение (англ. dirty read)* — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);  
*неповторяющееся чтение (англ. non-repeatable read)* — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;  
*фантомное чтение (англ. phantom reads)* — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.

**Уровни изолированности**

| Read uncommitted (чтение незафиксированных данных) | Низший (первый) уровень изоляции. Он гарантирует только отсутствие потерянных обновлений\[1\]. Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы. |
| :---- | :---- |
| Read committed (чтение фиксированных данных) | Большинство промышленных СУБД, в частности, Microsoft SQL Server, PostgreSQL и Oracle, по умолчанию используют именно этот уровень. На этом уровне обеспечивается защита от чернового, «грязного» чтения, тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных. |
| Repeatable read (повторяемость чтения) | Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена. |
| Serializable (упорядочиваемость) | Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения». |

#### **2\. Что такое DML/DDL/DCL?**

**DDL (Data Definition Language)** \- язык определения данных, используется для определения объектов базы данных (CREATE, ALTER, DROP).

**DML (Data Manipulation Language)** \- язык для манипуляции данными в базе данных (SELECT, INSERT, UPDATE, DELETE).

**DCL (Data Control Language)** \- язык для управления привилегиями на объектами базы данных (GRANT, REVOKE).

#### **3\. Что такое нормальные формы?**

**Нормальная форма** — свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности, потенциально приводящей к логически ошибочным результатам выборки или изменения данных. Нормальная форма определяется как совокупность требований, которым должно удовлетворять отношение. Существуют формы:

* Первая нормальная форма (1NF)

* Вторая нормальная форма (2NF)

* Третья нормальная форма (3NF)

* Нормальная форма Бойса — Кодда (BCNF)

* Четвёртая нормальная форма (4NF)

* Пятая нормальная форма (5NF)

* Доменно-ключевая нормальная форма (DKNF)

* Шестая нормальная форма (6NF)

Процесс преобразования отношений базы данных к виду, отвечающему нормальным формам, называется нормализацией. **Нормализация** предназначена для приведения структуры БД к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных.

Рассмотрим на примере первых трех форм.

Переменная отношения находится в первой нормальной форме тогда и только тогда, когда в любом допустимом значении этой переменной каждый кортеж отношения содержит только одно значение для каждого из атрибутов

| Сотрудник | Телефон |  | Сотрудник | Телефон |
| :---- | :---- | :---- | :---- | :---- |
| Иванов | 111-11-11222-22-22 |  | Иванов | 111-11-11 |
|  |  |  | Иванов | 222-22-22 |
| Петров | 333-33-33 |  | Петров | 333-33-33 |

Переменная отношения находится во второй нормальной форме тогда и только тогда, когда она находится в первой нормальной форме и каждый неключевой атрибут неприводимо зависит от (каждого) её потенциального ключа. Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.

| Филиал | Должность | Зарплата | Наличие телефона |
| :---- | :---- | :---- | :---- |
| Томск | Уборщик | 20000 | Нет |
| Москва | Программист | 40000 | Да |
| Томск | Программист | 60000 | Да |

Допустим, что зарплата зависит от филиала и должности, а наличие компьютера зависит только от должности. Существует функциональная зависимость Должность → Наличие компьютера, в которой левая часть является лишь частью первичного ключа, что нарушает условие второй нормальной формы. Следовательно необходимо декомпозировать на:

| Филиал | Должность | Зарплата |
| :---- | :---- | :---- |
| Томск | Уборщик | 20000 |
| Москва | Программист | 40000 |
| Томск | Программист | 60000 |

| Должность | Телефон |
| :---- | :---- |
| Уборщик | Нет |
| Программист | Да |

Переменная отношения находится в третьей нормальной форме тогда и только тогда, когда она находится во второй нормальной форме и ни один неключевой атрибут не находится в транзитивной функциональной зависимости от потенциального ключа.

| Сотрудник | Отдел | Телефон |
| :---- | :---- | :---- |
| Иванов | Бухгалтерия | 111-11-11 |
| Петров | Бухгалтерия | 111-11-11 |
| Сидоров | Снабжение | 222-22-22 |

Каждый сотрудник относится исключительно к одному отделу; каждый отдел имеет единственный телефон. Атрибут Сотрудник является первичным ключом. Личных телефонов у сотрудников нет, и телефон сотрудника зависит исключительно от отдела.

В примере существуют следующие функциональные зависимости: Сотрудник → Отдел, Отдел → Телефон, Сотрудник → Телефон.

Переменная отношения находится во второй нормальной форме, поскольку каждый атрибут имеет неприводимую функциональную зависимость от потенциального ключа Сотрудник.

Зависимость Сотрудник → Телефон является транзитивной, следовательно, отношение не находится в третьей нормальной форме.

| Отдел | Телефон |
| :---- | :---- |
| Бухгалтерия | 111-11-11 |
| Снабжение | 222-22-22 |

| Сотрудник | Отдел |
| :---- | :---- |
| Иванов | Бухгалтерия |
| Петров | Бухгалтерия |
| Сидоров | Снабжение |

#### **4\. Какие связи бывают между таблицами?**

**Один к одному**

Связь один к одному образуется, когда ключевой столбец присутствует в другой таблице, в которой тоже является ключом либо свойствами столбца задана его уникальность (одно и тоже значение не может повторяться в разных строках).

На практике связь «один к одному» наблюдается не часто. Например, она может возникнуть, когда требуется разделить данные одной таблицы на несколько отдельных таблиц с целью безопасности.

**Один ко многим**

В типе связей один ко многим одной записи первой таблицы соответствует несколько записей в другой таблице.

**Многие ко многим**

Если нескольким записям из одной таблицы соответствует несколько записей из другой таблицы, то такая связь называется «многие ко многим» и организовывается посредством связывающей таблицы.

#### **5\. Что такое JOIN? Стратегии соединения таблиц?**

**JOIN** — оператор языка SQL, который является реализацией операции соединения реляционной алгебры. Входит в предложение FROM операторов SELECT, UPDATE и DELETE.

Операция соединения предназначена для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор. Отличительными особенностями операции соединения являются следующие:

* 	в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть схема результата является «сцеплением» схем операндов;

* 	каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда.

Определение того, какие именно исходные строки войдут в результат и в каких сочетаниях, зависит от типа операции соединения и от явно заданного условия соединения. Условие соединения, то есть условие сопоставления строк исходных таблиц друг с другом, представляет собой логическое выражение (предикат). При необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).

Оператор внутреннего соединения **INNER JOIN** соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.

Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых таблиц. Тело результата логически формируется следующим образом. Каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы, после чего для полученной «соединённой» строки проверяется условие соединения (вычисляется предикат соединения). Если условие истинно, в таблицу-результат добавляется соответствующая «соединённая» строка.

Оператор левого внешнего соединения **LEFT OUTER JOIN** соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых таблиц. Тело результата логически формируется следующим образом. Пусть выполняется соединение левой и правой таблиц по предикату (условию) p. В результат включается внутреннее соединение (INNER JOIN) левой и правой таблиц по предикату p. Затем в результат добавляются те записи левой таблицы, которые не вошли во внутреннее соединение на предыдущем шаге. Для таких записей поля, соответствующие правой таблице, заполняются значениями NULL.

Оператор правого внешнего соединения **RIGHT OUTER JOIN** соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых таблиц. Тело результата логически формируется следующим образом. Пусть выполняется соединение левой и правой таблиц по предикату (условию) p. В результат включается внутреннее соединение (INNER JOIN) левой и правой таблиц по предикату p. Затем в результат добавляются те записи правой таблицы, которые не вошли во внутреннее соединение на предыдущем шаге. Для таких записей поля, соответствующие левой таблице, заполняются значениями NULL.

Оператор полного внешнего соединения **FULL OUTER JOIN** соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.

Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых таблиц. Тело результата логически формируется следующим образом. Пусть выполняется соединение первой и второй таблиц по предикату (условию) p. Слова «первой» и «второй» здесь не обозначают порядок в записи (который неважен), а используются лишь для различения таблиц. В результат включается внутреннее соединение (INNER JOIN) первой и второй таблиц по предикату p. В результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на предыдущем шаге. Для таких записей поля, соответствующие второй таблице, заполняются значениями NULL. В результат добавляются те записи второй таблицы, которые не вошли во внутреннее соединение на предыдущем шаге. Для таких записей поля, соответствующие первой таблице, заполняются значениями NULL.

Оператор перекрёстного соединения, или декартова произведения **CROSS JOIN** соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.

Заголовок таблицы-результата является объединением (конкатенацией) заголовков соединяемых таблиц. Тело результата логически формируется следующим образом. Каждая строка одной таблицы соединяется с каждой строкой второй таблицы, давая тем самым в результате все возможные сочетания строк двух таблиц. Если в предложении WHERE добавить условие соединения (предикат p), то есть ограничения на сочетания кортежей, то результат эквивалентен операции INNER JOIN с таким же условием.

**Стратегии соединения таблиц**

**Nested Loop** Join (NLJ) is the simplest join algorithm wherein each record of outer relation is matched with each record of inner relation.  
Nested Loop Join (NLJ) is the most common joining method and it can be used almost on any dataset with any type of join clause. Since this algorithm scan all tuples of inner and outer relation, it is considered to be the most costly join operation.

**Hash Join** \- this algorithm works in two phases:  
\- Build Phase: A Hash table is built using the inner relation records. The hash key is calculated based on the join clause key.  
\- Probe Phase: An outer relation record is hashed based on the join clause key to find matching entry in the hash table.

The join between relation A and B with condition A.ID \= B.ID can be represented as below:  
\-Build Phase  
\- For each tuple r in inner relation B  
\- Insert r into hash table HashTab with key r.ID  
\- Probe Phase  
\- For each tuple s in outer relation A  
\- For each tuple r in bucker HashTab\[s.ID\]  
\- If (s.ID \= r.ID)  
\- Emit output tuple (r,s)

**Merge Join** is an algorithm wherein each record of outer relation is matched with each record of inner relation until there is a possibility of join clause matching.

This join algorithm is only used if both relations are sorted and join clause operator is “=”.

#### **6\. Какая разница между WHERE и HAVING?**

1\. WHERE может быть использован с SELECT/UPDATE/DELETE, тогда как HAVING только с SELECT

2\. WHERE используется для фильтрации строк и применяется к каждой строке таблицы до выполнения GROUP BY, тогда как HAVING используется для фильтрации групп уже после выполнения GROUP BY, причем в HAVING для условий используются агрегатные функции (не запрещено использовать условия без агрегатных функций, но это не имеет смысла, т.к. более эффективно эти условия можно применить на этапе WHERE).

3\. Использование HAVING без GROUP BY вызовет ошибку, тогда как WHERE может использоваться в запросах без GROUP BY

Пример:

| select importance, count(\*) as cnt from \_alert\_base group by importance having count(\*) \> 3; |
| :---- |

#### **7\. Как соединить вывод двух таблиц с одинаковой структурой? Как получить результат без дубликатов?**

При помощи операций UNION ALL и UNION

#### 8\. Что такое ограничения в базе данных? Какие бывают виды?

**Ограничения (Constraints)** \- это набор правил, применяемый для всех записей таблицы. Если какая-либо запись нарушает указанные правила, то она не может быть сохранена в таблице по завершению транзакции. Ограничения задаются при создании таблицы (CREATE TABLE), либо при изменении существующей (ALTER TABLE).

Основные используемые ограничения:

| NOT NULL | Указывает, что значения в данном столбце должны быть не пустыми (NULL) |
| :---- | :---- |
| UNIQUE | Указывает, что значения в данном столбце должны быть уникальными |
| PRIMARY KEY | Указывает, что значения в данном столбце являются первичными ключами записей (удовлетворяют NOT NULL и UNIQUE) |
| FOREIGN KEY | Указывает, что значения в данном столбце являются внешними ключами записей, т.е. ссылаются на первичные ключи других таблиц. Данное ограничение используются для обеспечения целостности данных между таблицами. |
| CHECK | Указывает, что значения в данном столбце должны удовлетворят определенному заданному условию |

#### **9\. Что такое привилегии?**

Привилегии используются для установления прав доступа пользователям СУБД на соответствующие объекты СУБД. Основные команды: GRANT, REVOKE.

#### **10\. Какая разница между SQL и PL/PGSQL?**

**SQL** (structured query language — «язык структурированных запросов») — декларативный язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.

**PL/pgSQL** (англ. Procedural Language/PostGres Structured Query Language) — процедурное расширение языка SQL, используемое в СУБД PostgreSQL. Этот язык предназначен для написания функций, триггеров и правил и обладает следующими особенностями:

* 	добавляет управляющие конструкции к стандарту SQL;

* 	допускает сложные вычисления;

* 	может использовать все объекты БД, определенные пользователем;

#### **11\. Что такое хранимая процедура?**

**Хранимая процедура** — объект базы данных, представляющий собой набор инструкций, который компилируется один раз и хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.

#### **12\. Что такое триггер? Как бывают виды триггеров**

**Триггер** — хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением INSERT, удалением DELETE строки в заданной таблице, или изменением UPDATE данных в определённом столбце заданной таблицы реляционной базы данных. Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-логики. Триггер запускается сервером автоматически при попытке изменения данных в таблице, с которой он связан. Все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. Соответственно, в случае обнаружения ошибки или нарушения целостности данных может произойти откат этой транзакции. Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним события; например, до добавления записи) или AFTER (после события), а также вместо операции \- INSTEAD OF. Кроме того, триггеры могут быть привязаны не к таблице, а к представлению (VIEW). Также триггеры бывают Row-level, т.е. функция вызывается для каждой строки, которая попадает под модикацию, либо Statement-level, когда функция вызывается один раз для операции, внезависимости от того, сколько строк она изменила в таблице.

**Виды триггеров в PostgreSQL**

#### **13\. Что такое VIEW?**

**Представление**  — виртуальная (логическая) таблица, представляющая собой поименованный запрос (синоним к запросу), который будет подставлен как подзапрос при использовании представления.

В отличие от обычных таблиц реляционных баз данных, представление не является самостоятельной частью набора данных, хранящегося в базе. Содержимое представления динамически вычисляется на основании данных, находящихся в реальных таблицах. Изменение данных в реальной таблице базы данных немедленно отражается в содержимом всех представлений, построенных на основании этой таблицы.

**Материализованное представление** — физический объект базы данных, содержащий результат выполнения запроса. Материализованные представления позволяют многократно ускорить выполнение запросов, обращающихся к большому количеству. Это достигается за счет прозрачного использования заранее вычисленных итоговых данных и результатов соединений таблиц. Предварительно вычисленные итоговые данные обычно имеют очень небольшой объем по сравнению с исходными данными. Целостность данных в материализованных представлениях поддерживается за счёт периодических синхронизаций или с использованием триггеров.

Команда СREATE MATERIALIZED VIEW похожа на CREATE TABLE AS, за исключением того, что она запоминает запрос, инициализировавший представление, и который соответственно может быть использован для обновления данных.

#### **14\. Как создать таблицу по результату запроса?**

Использовать команду CREATE TABLE AS.

CREATE TABLE AS похожа на CREATE VIEW, но есть существенная разница: команда создает новую таблицу и выполняет запрос один раз для заполнения таблицы. Новая таблица не будет отслеживать изменения в исходных таблицах запроса.

#### **15\. Как постранично считывать информацию из таблицы? Когда применяется LIMIT/OFFSET \- до или после WHERE?**

LIMIT и OFFSET позволяют получить часть результата после выполнения запроса.

Если задан LIMIT, то будет возвращено не больше чем заданное количество строк

OFFSET указывает, что надо пропустить заданное количество строк перед выдачей результата.

Если в запросе есть и OFFSET, и LIMIT, то сначала пропускается заданное количество строк, а затем уже возвращается не больше указанного количества строк.

При использовании LIMIT важно использовать ORDER BY, чтобы возвращаемый набор строк был упорядочен единообразно, иначе каждый раз будет возвращаться непредсказуемый набор строк, т.к. СУБД без ORDER BY не гарантирует какой-либо порядок строк.

При использовании OFFSET серверу все равно надо обработать строки для того, чтобы их пропустить, соответственно большие значения OFFSET могут быть неэффективны. Поэтому на больших объемах для постраничного вывода применяют другие подходы: [https://www.citusdata.com/blog/2016/03/30/five-ways-to-paginate/](https://www.citusdata.com/blog/2016/03/30/five-ways-to-paginate/)

#### **16\. Что такое временная таблица?**

Временная таблица \- это таблица, которая автоматически удаляется по окончанию пользовательской сессии (или если указано по окончанию транзакции). Временные таблицы создаются в специальной схеме, соответственно имя схемы не может быть указано при создании таблицы. Для временной таблицы можно создать индекс, который также будет временным.

Создается командой:

CREATE TEMPORARY TABLE ... ON COMMIT {PRESERVER ROWS | DELETE ROWS | DROP}

#### **17\. Что такое индекс? Всегда ли выборка по нему оптимальна?**

Объект базы данных, создаваемый с целью повышения производительности поиска данных. Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра таблицы строка за строкой может занимать много времени. Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например, сбалансированного дерева.

Если по индексу выбирается более 20% записей таблицы, то с т.з. производительности СУБД быстрее сделать полное сканирование таблицы.

#### **18\. Что такое планировщик запросов?**

**Планировщик запросов** представляет собой упорядоченный набор шагов, используемых для доступа к данным в системе управления реляционными базами данных. Поскольку SQL является декларативным, обычно существует большое количество альтернативных способов выполнения заданного запроса с широким диапазоном производительности. Когда запрос отправляется в базу данных, оптимизатор запросов оценивает некоторые из различных, правильных возможных планов выполнения запроса и возвращает то, что он считает лучшим вариантом. Поскольку оптимизаторы запросов несовершенны, пользователям баз данных и администраторам иногда приходится вручную проверять и настраивать планы, созданные оптимизатором, для повышения производительности.

В настоящее время известны две стратегии поиска оптимального плана:

* грубой силы путём оценки всех перестановок соединяемых таблиц, используемых способов входа в таблицы и типов соединения (то есть полный перебор вариантов);

* на основе генетического алгоритма путём оценки ограниченного числа перестановок.

Также некоторые СУБД позволяют программисту вмешиваться в поиск оптимального плана в различной степени, от минимального влияния до полного и чёткого указания какой именно план запроса использовать. Например, в Oracle/MS-SQL есть hints для запросы в виде комментариев определенного вида /\*+ ... \*/, в Postgres специальные команды, для вкл/выкл типов сканирования (SET enable\_seqscan \= OFF).

Планы выполнения запроса сравниваются исходя из множества факторов (реализации в различных СУБД отличаются), в том числе:

* потенциальное число строк, извлекаемое из каждой таблицы, получаемое из статистики;

* наличие индексов;

* возможность выполнения слияний (merge-join);

* способ чтения записей/блоков таблиц/индексов.

В общем случае соединение выполняется вложенными циклами. Однако этот алгоритм может оказаться менее эффективен, чем специализированные алгоритмы. Например, если у сливаемых таблиц есть индексы по соединяемым полям, или одна или обе таблицы достаточно малы, чтобы быть отсортированными в памяти, то исследуется возможность выполнения слияний. Для больших таблиц может использоваться соединение с хешированием.

Вложенные циклы \- для каждой строки одной из таблиц (ведущей) выполняется поиск в другой таблице (ведомой) строк, соответствующих условию соединения.

Слияние \- входные таблицы должны быть отсортированы по столбцам, участвующим в условии соединения. Соединение осуществляется за одно сканирование (проход по) каждой из входных таблиц. То есть одна и та же строка считывается только один раз.

Соединение с хешированием \- алгоритм получает на вход две таблицы и условие соединения. Меньшая из двух входных таблиц помещается в специальную структуру данных в памяти: хэш-таблицу, которая обеспечивает очень высокую скорость поиска. Затем для каждой строки из большей таблицы выполняется поиск значений, соответствующих условию соединения. Результаты помещаются в выходную таблицу.

#### **19\. Какая разница между truncate и delete, drop и truncate?**

Основное отличие в том, что DELETE \- DML, TRUNCATE/DROP \- DDL.

DELETE используется для удаления определенных строк из таблицы (возможно и всех), TRUNCATE всегда удаляет все записи из таблицы.

DELETE можно использовать вместе с WHERE, TRUNCATE нельзя.

DROP удаляет таблицу целиком.

В Postgresql TRUNCATE/DROP могут быть отменены, если транзакция вызовет ROLLBACK.

#### **20\. Что такое ORM? Рассуждение на тему плюсов/минусов.**

**ORM** (англ. Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных».

Использование ORM в проекте избавляет разработчика от необходимости работы с SQL и написания большого количества кода, часто однообразного и подверженного ошибкам. Весь генерируемый ORM код предположительно хорошо проверен и оптимизирован, поэтому не нужно в целом задумывается о его тестировании. Это несомненно является плюсом, но в тоже время не стоит забывать и о минусах. Основной из них — это потеря производительности. Это происходит потому, что большинство ORM предназначены для обработки широкого спектра сценариев использования данных, гораздо большего, чем любое отдельное приложение когда-либо сможет использовать. Вопрос о целесообразности использования ORM по большому счету затрагивается только в больших проектах, которые сталкиваются с высокой нагрузкой, здесь приходится выбирать что более приоритетно — удобство или производительность? Конечно, работа с БД посредством грамотно написанного SQL-кода будет намного эффективнее, но не стоит забывать и о таком параметре, как время — то, что с легкостью пишется с использованием ORM за неделю, можно реализовывать ни один месяц собственными усилиями. Кроме того, большинство современных ORM позволяют программисту при необходимости самому задавать код SQL-запросов.

#### **21\. Есть три таблицы Города, Люди, Достопримечательности. Человек может жить только в одном Городе. В Городе может быть много Достопримечательностей.**

**Необходимо написать схему БД и запрос, как найти людей, живущих в городах без достопримечательностей.**

```sql
# towns
CREATE TABLE towns (
  id bigserial PRIMARY KEY,
  name text
);

INSERT INTO towns(name) VALUES ('Moscow'), ('Sochi'), ('Khimki');


# peoples
CREATE TABLE peoples (
  id bigserial PRIMARY KEY,
  fio text,
  town\_id bigint REFERENCES towns(id)
);

INSERT INTO peoples(fio, town\_id)
  VALUES('Vova', (SELECT id FROM towns WHERE name \= 'Moscow'));

INSERT INTO peoples(fio, town\_id)
  VALUES('Dima', (SELECT id FROM towns WHERE name \= 'Sochi'));

INSERT INTO peoples(fio, town_id)
  VALUES('Vasya', (SELECT id FROM towns WHERE name \= 'Khimki'));  


# places
CREATE TABLE places (
  id bigserial PRIMARY KEY,
  name text,
  town_id bigint REFERENCES towns(id)
);

INSERT INTO places(name, town_id)
  VALUES('Kremlin', (SELECT id FROM towns WHERE name = 'Moscow'));

INSERT INTO places(name, town_id)
  VALUES('Olympic Park', (SELECT id FROM towns WHERE name = 'Sochi'));


# Request

SELECT peoples.id, peoples.fio  
FROM peoples LEFT JOIN places ON peoples.town_id = places.town_id  
WHERE places.town_id IS NULL
```

#### **22\. Дана таблица empsalary(depname, empno, salary)**

**Необходимо написать запрос, который выводит информацию, представленную ниже.**

**Где avg \- средняя ЗП по департаменту**

| depname | empno | salary | avg |
| :---- | :---- | :---- | :---- |
| develop | 11 | 5200 | 5020.000000000000 |
| develop | 7 | 4200 | 5020.000000000000 |
| develop | 9 | 4500 | 5020.000000000000 |
| develop | 8 | 6000 | 5020.000000000000 |
| develop | 10 | 5200 | 5020.000000000000 |
| personnel | 5 | 3500 | 3700.000000000000 |
| personnel | 2 | 3900 | 3700.000000000000 |
| sales | 3 | 4800 | 4866.666666666667 |
| sales | 1 | 5000 | 4866.666666666667 |
| sales | 4 | 4800 | 4866.666666666667 |

\-- common request

```sql
SELECT empsalary.depname, empsalary.empno, empsalary.salary, t\_agg.avg\_s
FROM
  empsalary,
  (
	SELECT depname, avg(salary) as avg\_s
	FROM empsalary
	GROUP BY depname
  ) t_agg
WHERE
  empsalary.depname \= t\_agg.depname
```

\-- CTE

```sql
WITH t_agg AS (
  SELECT depname, avg(salary) as avg_s
  FROM empsalary
  GROUP BY depname
)

SELECT empsalary.depname, empsalary.empno, empsalary.salary, t\_agg.avg\_s
FROM
  empsalary, t\_agg
WHERE
  empsalary.depname \= t\_agg.depname
```

WITH предоставляет возможность написать вспомогательный подзапрос в больших запросах. Эти подзапросы называются \- Common Table Expressions (CTEs) \- и могут быть представлены как временные таблицы, которые существуют в рамках одного запроса.

\-- window function

```sql
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname)
FROM empsalary;
```

#### **23\. Для примера из вопроса выше, написать запрос, который выводит ранг зарплаты в рамках отдела по убыванию зарплаты**

| depname | empno | salary | rank |
| :---- | :---- | :---- | :---- |
| develop | 8 | 6000 | 1 |
| develop | 10 | 5200 | 2 |
| develop | 11 | 5200 | 2 |
| develop | 9 | 4500 | 4 |
| develop | 7 | 4200 | 5 |
| personnel | 2 | 3900 | 1 |
| personnel | 5 | 3500 | 2 |
| sales | 1 | 5000 | 1 |
| sales | 4 | 4800 | 2 |
| sales | 3 | 4800 | 2 |

```sql
SELECT
	depname, empno, salary,
	rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary; 
```

Чтобы ранг шел по порядку и не проскакивал значения (1 2 2 4 5 → 1 2 2 3 4\) используется функция dense\_rank

#### **24\. Как написать UNION между двумя таблицами без использования UNION?**

```sql
create table t1(msg text);  
insert into t1 values('Foo');  
insert into t1 values('Foo');  
insert into t1 values('Bar');

create table t2(msg text);  
insert into t2 values('Fuzz');  
insert into t2 values('Fuzz');  
insert into t2 values('Buzz');

\-- select msg from t1 union all select msg from t2  
select coalesce(msg\_i, msg\_j) as msg from  
	(select 0 as i, msg as msg\_i from t1) r1 full outer join  
	(select 1 as j, msg as msg\_j from t2) r2 on r1.i \= r2.j  
order by i, j

\-- select msg from t1 union select msg from t2  
select distinct msg from (  
	select coalesce(msg\_i, msg\_j) as msg from  
	(select 0 as i, msg as msg\_i from t1) r1 full outer join  
	(select 1 as j, msg as msg\_j from t2) r2 on r1.i \= r2.j  
	order by i, j  
) t
```

#### **25\. Задана таблица. Изначально есть значения только в столбцах a и b.**

| a | b | c |
| :---- | :---- | :---- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

**Необходимо написать UPDATE, который по столбцам a и b заполнит столбец c.**

```sql
UPDATE t SET c \= a \# b;
```

#### **26\. Дана таблица строк (strings)**

| str | str\_hash |
| :---- | :---- |
| aa | FOO |
| bbb | XX |
| ccccc | YY |

**Дана таблица хешей (hashes)**

| str\_len | hash\_val |
| :---- | :---- |
| 1 | AA |
| 3 | XX |
| 5 | YY |

Необходимо написать UPDATE для таблицы strings, чтобы поле str\_hash заполнилось значением хеша hash\_val из таблицы hashes, где длина строки str равна значению поля str\_len. Если не нашлось соответствия, то значением по умолчанию \- FOO.

```sql
UPDATE strings

SET str\_hash \= COALESCE((

  SELECT hashes.hash\_val

  FROM hashes

  WHERE char\_length(strings.str) \= hashes.str\_len

), 'FOO')
```
#### **27\. Что такое аггрегатная функция? Какие бывают аггрегатные функции общего назначения? Есть ли функция умножения (если нет, то как реализовать)?**

Аггрегатная функция вычисляет единственный результат из набора входных значений. Бывают аггрегатные функции общего назначения:

- *AVG \- среднее значение из всех входящих

* COUNT \- количество входящих значений

* MAX/MIN \- Максимальное/минимальное из входящих значений

* SUM \- сумма входящих значений

Аггрегатной функции умножения, как произведения всех входящих значений, в стандарте нет. Причина этому то, что даже небольшое количество столбцов с данными при умножении может переполнить тип данных результата.

Поэтому из\-за большой вероятности ошибочного использования функции она не была включена в стандарт.

Чтобы посчитать произведение столбцов можно воспользоваться математическими функциями:

| SELECT EXP(SUM(LN(t.value))) FROM t |
| :---- |

#### **28\. Что такое и как реализована многоверсионность в данных?**

[Ресурс](https://postgrespro.ru/blog/pgsql/17758)

**29\. Что такое EXPLAIN?**  
[Ресурс](https://habr.com/ru/companies/postgrespro/articles/574702/)