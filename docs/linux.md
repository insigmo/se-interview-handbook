# **Вопросы по линуксу**

#### **1\. Как происходит загрузка Linux-системы от включения питания до приглашения ввести логин и пароль?**

[https://en.wikipedia.org/wiki/Linux\_startup\_process](https://en.wikipedia.org/wiki/Linux_startup_process)

#### **2\. Что такое initrd и initramfs?**

**initrd** (initial ramdisk) \- схема загрузки временной корневой файловой системы в память, которая используется в процессе загрузки ОС. **initrd** и **initramfs** \- два разных метода выполнения данной задачи, но преследующие одну цель \- выполнение подготовительных действий для того, чтобы реальная корневая файловая система могла быть примонтирована.

Драйвера устройств для ядра Linux выполнены в качестве подгружаемых модулей. Их статическая компиляция в ядро привела бы к росту размеров самого ядра и невозможности загрузки на компьютерах с ограниченной памятью. В связи с этим появилась проблема обнаружения и загрузки необходимых модулей для монтирования корневой файловой системы \- т.е. необходимо загрузить в ядро модуль для работы с диском, который сам же находится на диске. Также для доступа к диску могут понадобиться дополнительные модули для работы с RAID, LVM и тд.

Для того, чтобы решить все эти проблемы, используется подход загрузки первоначальной корневой файловой системы, которая содержит в себе все необходимые модули для монтирования уже реальной корневой файловой системы. Образ этой первоначальной корневой файловой системы (вместе с образом ядра) должен находится в доступном месте для загрузчика системы. Загрузчик загружает ядро, образ корневой файловой системы и стартует ядро. Ядро, после инициализации, по образу корневой файловой системы определяет схему работу с ним.

При схеме **initrd** образ первоначальной корневой файловой системы выполнен в виде блочного устройства (/dev/ram), которое должно быть примонтировано. Соответственно, драйвера для монтирования (обычно ext2) должны быть статически скомпилированы в ядро. После монтирования, ядро запускает процесс /linuxrc, когда он завершается, ядро понимает, что реальная корневая файловая система загружена, и запускает процесс /sbin/init для начала процесса загрузки пользовательского окружения.

При схеме **initramfs** образ представляет собой cpio архив. Архив распаковывается ядром в инстанс tmpfs, которая и становится первоначальной корневой файловой системой. После этого, ядро запускает процесс /init, который далее выполняет все задачи, связанные с монтированием реальной корневой файловой системы и загрузки пользовательского окружения.

#### **3\. Как создавать deb- или rpm-пакеты, если есть архив с исходниками программы?**

[Ресурс](https://habr.com/ru/articles/78094/)

#### **4\. Зачем вообще нужны пакеты? Какие есть альтернативы?**

CheckInstall умеет создавать рабочий пакет, но он не поддерживает все вкусности, на которые способны deb пакеты :) А именно:  
Скрипты, выполняющиеся до, после и вместо установки пакета :)  
Автоматическое управление конфигурационными файлами: пакет не позволит затереть старые конфиги новыми без спроса  
Работа с шаблонами: возможность задавать пользователю вопросы при установке (\!\!\!)  
Изменение файлов других пакетов

#### **5\. В чем плюсы и минусы использования dd или tar/rsync для бэкапов системы?**

[Ресурс](https://integrus.ru/blog/it-decisions/rezervnoe-kopirovanie-serverov-linux-unix.html)

#### **6\. Как сделать подготовить окружение chroot?**

[Ресурс](https://www.8host.com/blog/podgotovka-chroot-okruzhenij-dlya-testirovaniya-na-servere-ubuntu-12-04/)

#### **7\. Что такое pipe? Что такое unix socket?**

**pipe** \- это механизм коммуникации между процессами. pipe, является однонаправленным потоком данных, все данные, записанные процессом в пайп перенаправляются ядром другому процессу для чтения.  
pipe это объект VFS (Virtual File System), поэтому pipe не имеет соответсвутющего образа на диске, грубо говоря он хранится в памяти (pipefs).  
Главным недостатком pipe является тот факт, что невозможно открыть уже существующий pipe. Поэтому два произвольных процесса не могут использовать одновременно один и тот же pipe, за исключением случаев если pipe был создан общим родительским процессом.

**fifo (named pipe)** \- это специальный файл, очень похожий на pipe, за исключением того, что fifo inode содержится в файловой системе, плюс fifo это двунаправленный механизм обмена данными между двумя и более процессами, поэтому доступ к fifo на чтение и запись может получить любой процесс. Грубо говоря процесс общения с использованием fifo выглядит следующим образом \- "сервер" создает fifo файл, который успользуется "клиентами" для выполнения запросов. Каждый "клиент", прежде чем установить соединение с "сервером", создает другой fifo файл, в который "сервер" может записать ответ клиенту, при это указывая имя fifo в изначальном запросе.

**socket (unix socket)** \- это специальный файл, используемый для коммуникации между двумя и более различными процессами, выполняющимися на одной машине. Процессы обращаются к socket по его inode.

Итак в чем же отличие fifo (named pipe) от unix socket:  
1\. "Сервер" (или принимающий процесс) в fifo не умеет различать "Клиентов".  
"Клиенты", использующие unix socket имеют отдельные соединения с сервером. В fifo различные "клиенты" могут писать в pipe, но "Сервер" не может различить "Клиентов" друг от друга.  
2\. При создании fifo и unix socket используются различные системные вызовы.  
Unix socket создается системным вызовом "socket()". fifo создается "mkfifo()"  
3\. Для подключения к fifo и unix используюся различные системные вызовы.

Сравнение по производительности \- fifo vs unix socket:  
1\. unix socket обеспечивает лучшую производительнось при передаче большого объема данных  
2\. для малых объемов unix socket уступает в производительности fifo. это вызвано накладными раскодами, связанными с созданием сокета, инициализацией и подключением к нему.

#### **8\. Что такое зомби-процесс?**

Проце́сс-зо́мби, зо́мби (англ. zombie process, англ. defunct process) — дочерний процесс в Unix-системе, завершивший своё выполнение, но ещё присутствующий в списке процессов операционной системы, чтобы дать родительскому процессу считать код завершения.

#### **9\. Какая разница между фоновым процессом и процессом-демоном?**

**Фоновый процесс** обычно означает процесс, который:  
\- Другой процесс является его родителем; например, оболочка;  
\- Он имеет стандартные потоки (ввод, вывод, ошибки), связанные с этим родителем.  
Наиболее распространенный тип \- запуск программы-оболочки с концевым &. Она обычно использует выходные потоки оболочки, но получит сигнал и остановится, если попытается прочитать из своего входного потока.  
Что еще более важно (обычно), такой фоновый процесс все еще является родительским, поэтому сигналы, поступающие в группу процессов, будут передаваться и ему. Если родительский процесс завершается, дочерние получат сигналы, которые, скорее всего, завершат и их. (Это, вероятно, самая большая разница между ними для большинства пользователей).  
Процесс-демон \- это процесс, который:  
\- Не имеет родителя, то есть его родительским процессом является начальный поток системы (или контейнера), обычно systemd (Linux), init (другие Unix) или launchd (MacOS);  
\- Обычно имеет отсоединенный выход или подключен к файлу журнала;  
\- Как правило, его вход отключен.

**Процесс Daemon** \- это процесс, который:  
\- Не имеет родителя, то есть его родительским процессом является начальный поток системы (или контейнера), обычно systemd (Linux), init (другие Unix) или launchd (MacOS);  
\- Обычно имеет отсоединенный выход или подключен к файлу журнала;  
\- Как правило, его вход отключен.  
Обычно демоны также написаны так, чтобы принимать сигнал "пользователь завис" (SIGHUP), который завершает работу программы, если его не обработать, как специальную инструкцию для перечитывания своих конфигурационных файлов и продолжения работы.  
Чаще всего это процессы, созданные каким-либо средством системного уровня, которые продолжают работать совершенно независимо от действий пользователя (входов, выходов и т. п.). Вещи, которые сами обрабатывают логины (getty или gdm и т. п.), а также другие сетевые службы (веб-серверы, почтовые серверы и т. п.) могут быть демонами, равно как и самоконтролирующиеся службы вроде cron или smartd.

#### **10\. В чем разница между именем файла, символической и жесткой ссылками, и bind mount?**

**Имя файла** \- запись в каталоге с ссылкой на inode с данными файла

**Символическая ссылка** \- специальный тип файла который указывает на другой файл. Путь до другого файла может быть как относительный, так и абсолютный, может быть на другой файловой системе и может вообще не существовать на момент создания ссылки

**Жесткая ссылка** \- еще одна запись в каталоге со ссылкой на тот же inode, что и оригинальный файл. Может существовать только в рамках одной файловой системы.

**Bind mount** \- это монтирование на уровне ядре одного каталога в другой. Отличие от ссылок:

\-- запись на уровне ядра, если не прописано в /etc/fstab, после рестарта ОС не сохранится

\-- нельзя сделать жесткую ссылку для каталогов, но можно bind mount

\-- символическая ссылка не выходит за предел chroot, а при помощи bind mount можно подмонтировать внешнюю директорию в chroot

#### **11\. У какого процесса PID \= 1?**

Самый первый процесс init, текущая реализация systemd, который запускает другие процессы

#### **12\. Какие атрибуты есть у процесса?**

Например pid, umask, uid, gid, euid, egid, обработчики сигналов, ppid, pgid, sid, статус процесса, регистры, счетчик инструкций, открытые файловые дескрипторы, текущая рабочая директория и тд

#### **13\. Чем отличаются uid/gid от euid/egid?**

uid/gid \- идентификаторы пользователя

euid/egid \- эффективные идентификаторы процесса пользователя, которые либо равны uid/gid, либо устанавливаются в зависимости от setuid бита исполняемого файла процесса. Например когда пользователь запускает команду passwd, чтобы поменять пароль, его эффективные идентификаторы становятся как у root, что позволяет делать запись в /etc/passwd | /etc/shadow.

#### **14\. Какие бывают системы прав?**

Биты доступа rwxrwxrwx

ACL

Мандатные

#### **15\. Почему cd это команда оболочки, а не отдельная программа?**

cd реализована именно встроенной командой, потому что оболочке надо поменять свою текущую рабочую директорию.

Если бы cd была отдельной программой, то оболочка запускала бы её и та меняла бы свою рабочую директорию (тк рабочая директория атрибут процесса). Но при выходе рабочая директория оболочки оставалась бы той же. Поэтому, чтобы не усложнять задачу замены рабочей директории родительского процесса из дочернего, cd была сделана как встроенная команда оболочки

#### **16\. Как удалить очень много файлов быстро?**

1\) rm \- самая долгая, тк команда вызывается для каждого найденного файла

2\) find /test \-type f \-exec rm {} \- быстрее, но по сути как (1)

3\) find ./ \-type f \-delete \- еще быстрее

4\) perl \-e 'for(\<\*\>){((stat)\[9\]\<(unlink))}' \- самая быстрая

5\) rsync \-a \--delete emptydir/ test/ \- тоже достаточно быстрая

#### **17\. Debugging.** 

#### **17.1 Как искать проблему в зависшем скрипте на сервере?** 

lsof \-p 123

#### **17.2 Как увидеть, к каким файлам программа обращается во время своей работы?**

ls \-l /proc/123/fd

#### **18\. Shell scripting.** 

#### **18.1 Как сохранить путь текущей директории в переменную shell?**

VAR=\`pwd\`

**18.2 Что будет если набрать в консоли \`cp \*\` ?**

**18.3 Что будет если добавить в шел-скрипт \`set \-e\`, \`set \-x\`? Какая область действия у этих директив?**

**18.4 В чем разница между /bin/sh и /bin/bash**

**18.5 Что делает команда \`chown .docker myfile\`**

Устанавливается группу docker для файла myfile. Также можно указывать через ":".

chown :docker myfile.

Установить и владельца и группу можно так:

chown docker.docker myfile

**18.6 Как посмотреть код возврата предыдущей команды в bash?**

echo $?

**18.7 Как в crontab перенаправить вывод скрипта (out,err) в выходной дескриптор самого cron?**

\# crontab \-l

\* \* \* \* \* /script.sh \> /proc/$(cat /var/run/crond.pid)/fd/1 2\>&1

**18.8 Как найти самую длинную строку в файле?**

*cat filename | awk '{print length, $0}' | sort \-nr | head \-1*

